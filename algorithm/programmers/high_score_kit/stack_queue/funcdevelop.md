# 기능개발


## 문제

### 설명
프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다.

또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다.

먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요.

### 입력
- 작업의 진도가 적힌 정수 배열 progresses
- 각 작업의 개발 속도가 적힌 정수 배열 speeds

### 출력
- 각 배포마다 배포되는 기능의 개수

### 제한사항
- 작업의 개수(progresses, speeds배열의 길이)는 100개 이하
- 작업 진도는 100 미만의 자연수
- 작업 속도는 100 이하의 자연수
- 배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정한다. 예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어진다.


## 해결방안
- 뒤에 있는 기능은 앞의 있는 기능보다 먼저 배포하지 못한다. 따라서 선형탐색을 통해 높은 개발 기간을 기준으로 정하여 해당 기준보다 높은 개발 기간이 나오기 전까지의 개발 작업들을 해당 기준에 카운팅시켰다.
    - 즉, 각 개발 기간이 얼마나 걸리는지를 측정하여 새로운 max값이 나오기 전까지 카운팅시키고, 새 max값이 나오면 새 배포 요소로 추가한다.
    - 예를 들어, progresses는 [95, 90, 99, 99, 80, 99]이고 speeds는 [1, 1, 1, 1, 1, 1]이면 각 개발 기간은 [5, 10, 1, 1, 20, 1]이 나온다. 여기서 위의 내용대로 나눠보면 [[5], [10, 1, 1], [20, 1]] 이렇게 나눌 수 있다.


## 코드 분석
```python3
def solution(progresses, speeds):
    answer = []
    days = []
    
    status = 0 # 현재 기준이 되는 일
    count = -1 # answer에 들어간 숫자 개수
    for i in range(len(progresses)):
        days.append(((100 - progresses[i]) // speeds[i]) + (1 if (100 - progresses[i]) % speeds[i] else 0)) # 올림 기능 대신
        
    for i in range(len(days)):
        if days[i] > status: # 기준이 되는 일 보다 크면 기준을 바꾼다.
            status = days[i]
            answer.append(1)
            count = count + 1
        else: # 작으면 해당 일의 배포 개수를 증가시킨다
            answer[count] = answer[count] + 1

    return answer
```
- 작성한 코드의 해시 값 입력, 탐색 모두 O(n)의 시간복잡도를 가진다.
